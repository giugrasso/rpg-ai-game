# backend/app/main.py
import logging
import os
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import uuid4

import requests
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, status

# Ollama async client
from ollama import AsyncClient  # pip install ollama
from pydantic import BaseModel, Field, field_validator

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

app = FastAPI(title="RPG AI Game - Scenario-driven Backend (Async Ollama)")

load_dotenv(".env")  # load env vars from .env file

AI_MODEL = os.getenv("OLLAMA_MODEL", "LLAMA3.2")  # default model if not set in env


# ---------------------------
# Models
# ---------------------------
class GameMode(str, Enum):
    PVE = "PvE"
    PVP = "PvP"


class CharacterRole(BaseModel):
    name: str
    stats: Dict[str, int]  # e.g. {"force":10, "intel":14}
    description: Optional[str] = None


class Scenario(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    description: str
    objectives: str
    mode: GameMode
    max_players: int
    roles: Dict[str, CharacterRole]  # role name -> role definition
    context: str  # big blob used to feed the AI (rules, lore, NPCs, objectives)


class Character(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    player_id: str
    display_name: str
    role: str
    stats: Dict[str, int]
    hp: float
    mp: float
    position: Optional[str] = "start"


class Game(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    scenario_id: str
    players: List[Character] = []
    turn: int = 0
    history: List[Dict] = []  # list of action dicts with timestamp
    active: bool = True
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_updated: datetime = Field(default_factory=datetime.utcnow)


class CreateGameRequest(BaseModel):
    scenario_id: str
    initial_players: Optional[List[Character]] = []


class ActionRequest(BaseModel):
    player_id: str
    action: str  # free text describing the action the player wants to take
    meta: Optional[Dict] = (
        None  # optional structured metadata (weapon, target, position, etc.)
    )


class Option(BaseModel):
    id: int
    description: str
    success_rate: float = Field(ge=0.0, le=1.0)  # estimated success rate (0.0 to 1.0)
    health_point_change: float = Field(ge=-1.0, le=1.0)
    mana_point_change: float = Field(ge=-1.0, le=1.0)
    related_stat: str  # e.g. "force", "intelligence", etc.


class AIResponse(BaseModel):
    narration: str
    options: List[Option] = []

    @field_validator("options", mode="before")
    def validate_options(cls, v):
        if v is None:
            return []
        return v


class ChooseOptionRequest(BaseModel):
    player_id: str
    option_id: int


# ---------------------------
# In-memory "DB" (prototype)
# ---------------------------
SCENARIOS: Dict[str, Scenario] = {}
GAMES: Dict[str, Game] = {}

# ---------------------------
# Ollama client (singleton)
# ---------------------------
# You can configure host via env vars if needed, e.g. AsyncClient(host="http://ollama:11434")
ollama_client = AsyncClient(
    host="http://ollama:11434"
)  # default talks to localhost:11434


# ---------------------------
# Endpoints: Scenarios
# ---------------------------
@app.post("/scenarios", response_model=Scenario, status_code=201)
async def create_scenario(scenario: Scenario):
    if scenario.id in SCENARIOS:
        raise HTTPException(status_code=409, detail="Scenario already exists")
    SCENARIOS[scenario.id] = scenario
    logger.info(f"Scenario created: {scenario.id}")
    return scenario


@app.get("/scenarios", response_model=List[Scenario])
async def list_scenarios():
    return list(SCENARIOS.values())


@app.get("/scenarios/{scenario_id}", response_model=Scenario)
async def get_scenario(scenario_id: str):
    scenario = SCENARIOS.get(scenario_id)
    if not scenario:
        raise HTTPException(status_code=404, detail="Scenario not found")
    return scenario


# ---------------------------
# Endpoints: Games
# ---------------------------
@app.post("/games", response_model=Game, status_code=201)
async def create_game(req: CreateGameRequest):
    scenario = SCENARIOS.get(req.scenario_id)
    if not scenario:
        raise HTTPException(status_code=404, detail="Scenario not found")

    if len(req.initial_players or []) > scenario.max_players:
        raise HTTPException(
            status_code=400, detail="Too many initial players for scenario"
        )

    game = Game(scenario_id=scenario.id, players=req.initial_players or [])
    GAMES[game.id] = game
    logger.info(f"Game created: {game.id}")
    return game


@app.get("/games", response_model=List[Game])
async def list_games():
    return list(GAMES.values())


@app.get("/games/{game_id}", response_model=Game)
async def get_game(game_id: str):
    game = GAMES.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    return game


@app.post("/games/{game_id}/join", response_model=Game)
async def join_game(game_id: str, character: Character):
    game = GAMES.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    scenario = SCENARIOS.get(game.scenario_id)
    if not scenario:
        raise HTTPException(status_code=500, detail="Scenario missing")

    if len(game.players) >= scenario.max_players:
        raise HTTPException(status_code=400, detail="Game is full")

    # validate role exists in scenario
    if character.role not in scenario.roles:
        raise HTTPException(
            status_code=400, detail="Role not allowed for this scenario"
        )

    game.players.append(character)
    game.last_updated = datetime.utcnow()
    logger.info(f"Player {character.player_id} joined game {game_id}")
    return game


# ------------------------------
# Build prompt pour l'action
# ------------------------------
def build_prompt_for_action(
    scenario: Scenario, game: Game, action: ActionRequest
) -> str:
    prompt = f"Scenario: {scenario.name}\n"
    prompt += f"Description: {scenario.description}\n"
    prompt += f"Context: {scenario.context}\n"
    prompt += f"Objectives: {scenario.objectives}\n"
    prompt += "Players:\n"
    for p in game.players:
        prompt += f"- ID:{p.player_id} Nom:{p.display_name} ({p.role}) HP:{p.hp} MP:{p.mp} Stats:{p.stats}\n"
    prompt += f"\nAction by {action.player_id}: {action.action}\n"
    # prompt += (
    #     "Repond au format JSON en compl√©tant tous les champs"
    # )
    return prompt


# ------------------------------
# Endpoint: Action
# ------------------------------
@app.post("/games/{game_id}/action", response_model=AIResponse)
async def game_action(game_id: str, action: ActionRequest):
    game = GAMES.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    scenario = SCENARIOS.get(game.scenario_id)
    if not scenario:
        raise HTTPException(status_code=500, detail="Scenario not found")
    player = next((p for p in game.players if p.player_id == action.player_id), None)
    if not player:
        raise HTTPException(status_code=400, detail="Player not part of this game")

    prompt = build_prompt_for_action(scenario, game, action)
    logger.info(f"Prompt sent to Ollama:\n{prompt}")

    try:
        resp = await ollama_client.generate(
            model="game_master",
            prompt=prompt,
            stream=False,
            format=None,
        )
        raw_response = getattr(resp, "response", str(resp))
        logger.info(f"Raw AI response: {raw_response}")

        # Parse and validate the AI response
        try:
            parsed = AIResponse.model_validate_json(raw_response)
        except Exception as e:
            logger.error(f"Failed to parse AI response: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Invalid AI response format: {e}",
            )

        # Stocker les options dans l'historique sous forme de liste de dictionnaires
        game.history.append(
            {
                "timestamp": datetime.utcnow().isoformat(),
                "actor": action.player_id,
                "action": action.action,
                "ai_narration": parsed.narration,
                "options": [opt.model_dump() for opt in parsed.options],  # Conversion en dict
            }
        )
        game.turn += 1
        game.last_updated = datetime.utcnow()
        return parsed
    except Exception as exc:
        logger.error(f"Ollama call failed: {exc}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ollama call failed: {exc}",
        )


@app.get("/games/{game_id}/history", response_model=List[Dict])
async def game_history(game_id: str):
    game = GAMES.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    return game.history


@app.get("/config/get_model")
async def get_ollama_model():
    """Check if the custom Ollama model exists."""
    try:
        resp = requests.get("http://ollama:11434/api/tags")
        resp.raise_for_status()
        models = resp.json()
        for m in models["models"]:
            if m.get("name") == "game_master:latest":
                return {"model_exists": True}
        return {"model_exists": False}
    except Exception as exc:
        logger.error(f"Failed to check Ollama model: {exc}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to check Ollama model: {exc}",
        )


@app.post("/config/set_model")
async def set_ollama_model():
    payload = {
        "model": "game_master",
        "from": AI_MODEL,
        "system": f"""
‚ö†Ô∏è R√àGLE ABSOLUE : TU DOIS **TOUJOURS** r√©pondre avec un JSON valide **ET RIEN D'AUTRE**.
Ne commence **JAMAIS** ta r√©ponse par du texte comme "Voici la r√©ponse :", "Le joueur voit...", ou toute autre narration en dehors du JSON.
Si tu ne respectes pas cette r√®gle, le jeu ne fonctionnera pas.

---
### R√¥le et Responsabilit√©s
Tu es un **ma√Ætre du jeu (MJ) expert** pour un jeu de r√¥le narratif. Ton objectif est de :
1. **Cr√©er une immersion totale** en d√©crivant les sc√®nes, personnages et √©v√©nements avec des d√©tails **sensoriels** (sons, odeurs, textures, ambiance).
2. **Adapter dynamiquement l'histoire** au sc√©nario, aux actions des joueurs et √† leurs statistiques.
3. **Guider subtilement les joueurs vers l'objectif principal** du sc√©nario **sans le r√©v√©ler explicitement**.
    - Utilise des indices environnementaux (ex : "Un bruit vient de la direction de ton objectif...").
    - √âvite les digressions qui n'avancent pas l'histoire.
4. **Respecter les r√®gles du monde** (ex : pas de magie dans un sc√©nario scientifique, pas de technologie futuriste dans un monde m√©di√©val).
5. **G√©rer les actions risqu√©es** (combats, pi√®ges, n√©gociations) avec des m√©caniques de succ√®s/√©chec bas√©es sur les statistiques des joueurs.

---
### Structure de R√©ponse Obligatoire
Ton JSON doit **toujours** suivre ce sch√©ma :
{AIResponse.model_json_schema()}

---
### R√®gles pour les Options
- **Nombre** : Propose **toujours 2 ou 3 options** (sauf cas exceptionnel justifi√© par le sc√©nario).
- **Vari√©t√©** :
    - Une option doit avoir un `success_rate` **√©lev√©** (> 0.6) et un risque faible.
    - Une option doit avoir un `success_rate` **faible** (< 0.4) mais un gain potentiel important.
    - Les valeurs de `health_point_change`/`mana_point_change` doivent √™tre **coh√©rentes** avec le risque (ex : une attaque puissante a un `health_point_change` n√©gatif √©lev√©).
- **Lien avec les stats** :
    - `related_stat` doit correspondre √† une statistique du joueur (ex : "force" pour un combat, "intelligence" pour r√©soudre une √©nigme).
    - Une option ne peut pas d√©pendre d'une stat que le joueur n'a pas.
- **Coh√©rence** :
    - Les effets (`health_point_change`, `mana_point_change`) doivent √™tre **r√©alistes** dans le contexte (ex : une potion de soin ne restaure pas 100% des PV si le sc√©nario est difficile).
    - Si une action est impossible (ex : "voler sans ailes"), fixe `success_rate=0.0` et propose des alternatives.

---
### Gestion des Cas Sp√©ciaux
- **Actions absurdes/hors contexte** :
    - Narration : D√©cris l'√©chec de mani√®re immersive (ex : "Ton personnage, sous l'emprise d'une illusion, tente de parler aux murs...").
    - Options : Propose des moyens de **revenir √† une situation normale** (ex : "Secouer la t√™te pour te ressaisir").
    - `success_rate` : 0.0 pour l'action absurde, > 0.5 pour les options de rattrapage.
- **Objectif du sc√©nario** :
    - Toutes les options doivent **indirectement rapprocher** les joueurs de l'objectif (m√™me apr√®s un √©chec).
    - Utilise des PNJ, des √©v√©nements ou des indices pour **recadrer l'histoire** si les joueurs s'√©loignent trop.
- **Combats/Conflits** :
    - D√©cris les ennemis, leur √©tat (bless√©s, enrag√©s, affaiblis) et les cons√©quences des actions.
    - Les d√©g√¢ts (`health_point_change`) doivent √™tre **proportionnels** √† la menace (ex : un boss inflige plus de d√©g√¢ts qu'un ennemi basique).

---
### Consignes Suppl√©mentaires
- **Langue** : R√©ponds **uniquement en fran√ßais**, avec un style **vivant et captivant**.
- **√âquilibre** :
    - Un joueur ne doit **jamais** √™tre bloqu√© sans solution (m√™me apr√®s un √©chec).
    - Les r√©compenses/risques doivent √™tre **√©quilibr√©s** (ex : un tr√©sor bien gard√© a un haut risque mais une grande r√©compense).
- **Dynamicit√©** :
    - Fais √©voluer l'environnement en fonction des actions (ex : un dinosaure bless√© peut fuir ou devenir plus agressif).
    - Les PNJ ont des personnalit√©s et r√©agissent de mani√®re coh√©rente (ex : un scientifique aura peur des dinosaures).
- **Immersion** :
    - Utilise des **m√©taphores** et des **comparaisons** pour rendre les descriptions plus vivantes (ex : "Le rugissement du raptor ressemble √† un moteur qui tousse").
    - Varier les sens utilis√©s (ou√Øe, odorat, toucher) pour enrichir l'exp√©rience.

---
### Interdictions Formelles
- ‚ùå **Ne r√©v√®le JAMAIS** l'objectif du sc√©nario ou des √©l√©ments cl√©s √† l'avance.
- ‚ùå **Ne brise JAMAIS l'immersion** (m√™me pour une action absurde, trouve une explication narrative).
- ‚ùå **Ne d√©passe JAMAIS** les limites des multiplicateurs :
    - `health_point_change` et `mana_point_change` doivent toujours √™tre entre **-1.0 et 1.0**.
    - `success_rate` doit toujours √™tre entre **0.0 et 1.0**.
- ‚ùå **N'invente pas** de nouvelles statistiques ou comp√©tences pour les joueurs.
""",
    }

    # headers = {"Content-Type": "application/json"}

    try:
        resp = requests.post("http://ollama:11434/api/create", json=payload)
        resp.raise_for_status()
        logger.info("Custom Ollama model created successfully.")
        return {"status": f"model game_master created based on {AI_MODEL}"}
    except Exception as exc:
        logger.error(f"Failed to create Ollama model: {exc}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create model: {exc}",
        )


# ---------------------------
# Simple example to prefill a scenario
# ---------------------------
@app.on_event("startup")
async def startup_event():
    # create a demo StarWars-like scenario as illustration
    sc = Scenario(
        name="L'ile des dinosaures",
        description="Une ile myst√©rieuse peupl√©e de dinosaures issus d'une exp√©rience scientifique.",
        objectives="Survivre, trouver le scientifique George, et atteindre l'h√©liport.",
        mode=GameMode.PVE,
        max_players=4,
        roles={
            "Chasseur": CharacterRole(
                name="Chasseur",
                stats={
                    "force": 18,
                    "intelligence": 12,
                    "charisme": 14,
                    "courage": 16,
                    "chance": 10,
                },
                description="Utilise des armes √† feu et des pi√®ges",
            ),
            "Scientifique": CharacterRole(
                name="Scientifique",
                stats={
                    "force": 10,
                    "intelligence": 18,
                    "charisme": 12,
                    "courage": 8,
                    "chance": 14,
                },
                description="Expert en biologie et en technologie",
            ),
        },
        context="""
**Contexte connu des joueurs (√† r√©v√©ler progressivement) :**
Vous venez de d√©barquer de nuit sur une √Æle tropicale isol√©e, apr√®s avoir r√©pondu √† un appel de d√©tresse lanc√© par une station de recherche scientifique.
Le message √©tait incomplet, mais mentionnait une "urgence biologique" et une √©vacuation par h√©liport au centre de l'√Æle.
Votre mission initiale : localiser le Dr. George, le responsable de la station, et vous rendre √† l'h√©liport pour une extraction d'urgence.

**Ce que les joueurs ignorent (√† d√©couvrir via l'exploration) :**
- L'√Æle abritait un **projet de recherche secret** sur la **r√©surrection d'esp√®ces √©teintes**, financ√© par une organisation inconnue.
- Une **panne de courant g√©n√©rale** a plong√© les installations dans le chaos il y a 48 heures. Depuis, plus aucun contact avec l'ext√©rieur.
- Les syst√®mes de s√©curit√© sont hors ligne, et les **portes des enclos de quarantaine** se sont ouvertes...
- Des **bruits √©tranges** (grondements, craquements de v√©g√©tation) r√©sonnent dans la jungle, surtout la nuit.
- Les rares notes retrouv√©es parlent de "sujets d'exp√©rience non contr√¥l√©s" et de "protocole Ichthyosaure" (un code interne).

**√âl√©ments cl√©s √† d√©couvrir :**
- **George** : Le scientifique en chef. D'apr√®s les transmissions intercept√©es, il se dirigeait vers le **bunker central** (pr√®s de l'h√©liport) avec des √©chantillons "critiques".
  - *Indices pour le trouver* :
    - Une carte partielle de l'√Æle (trouvable dans le camp de base) montre un chemin vers le centre.
    - Des **traces de pas humains** r√©centes m√®nent vers les collines centrales.
    - Des **messages audio** dispers√©s (via talkies-walkies) mentionnent un "protocole d'urgence activ√©".
- **L'h√©liport** : Situ√© au c≈ìur de l'√Æle, c'est le seul point d'√©vacuation. Son g√©n√©rateur de secours clignote encore, visible de loin la nuit.
  - *Obstacles* :
    - La jungle est dense, avec des **zones marqu√©es "DANGER - ACC√àS RESTREINT"** (anciens enclos).
    - Des **c√¢bles √©lectriques arrach√©s** et des **√©quipements endommag√©s** jonchent les sentiers.
- **Ressources** :
  - Nourriture et eau sont limit√©es. Les joueurs devront **piller les caches de la station** ou chasser (avec des risques).
  - Des **armoires m√©dicales** (dans les avant-postes) contiennent des soins, mais certaines sont vides... ou ouvertes de l'int√©rieur.
- **R√®gles de survie** :
  - **Jets de d√©s** : Toute action risqu√©e (escalade, combat, fouille) d√©pend des stats des joueurs.
  - **Gestion des ressources** : Un inventaire limit√© force √† faire des choix (ex : garder une lampe torche ou des munitions).
  - **Rencontres al√©atoires** : Des **bruits inexpliqu√©s** (feuillages qui bougent, souffles chauds) peuvent survenir, surtout pr√®s des zones restreintes.

**Ambiance √† instaurer :**
- **Jour** : L'√Æle semble d√©serte, mais des d√©tails trahissent une pr√©sence (ex : branches cass√©es √† 3 m√®tres de haut, odeurs musqu√©es).
- **Nuit** : Les bruits s'intensifient. Une **lueur verd√¢tre** √©mane parfois des zones restreintes...
- **Indices environnementaux** :
  - Des **cages vides** (portes arrach√©es) pr√®s des laboratoires.
  - Des **cadavres d'animaux** (moutons, singes) partiellement d√©vor√©s, avec des morsures anormalement larges.
  - Des **√©crans de surveillance** (si r√©activ√©s) montrent des silhouettes se d√©pla√ßant rapidement entre les arbres.

**Objectif cach√© (pour le MJ) :**
- Les "sujets d'exp√©rience" sont des **dinosaures g√©n√©tiquement modifi√©s**, con√ßus pour √™tre dociles... jusqu'√† la panne.
- George sait comment les neutraliser (via un **√©metteur √† ultrasons** dans son labo), mais il est bless√© et traqu√©.
- L'h√©liport a un **syst√®me de verrouillage** n√©cessitant un code (que George poss√®de).

**Ton en tant que MJ :**
- D√©cris l'√Æle comme **belle mais inqui√©tante** : plages de sable blanc contrastant avec des b√¢timents vandalis√©s, odeurs de jungle m√©lang√©es √† un **ar√¥me m√©tallique** (sang ? produits chimiques ?).
- Utilise des **m√©taphores** pour √©voquer les dinosaures sans les nommer :
  - *"Un grognement sourd fait vibrer le sol, comme un moteur diesel au ralenti."*
  - *"Une ombre massive passe entre les arbres, trop grande pour un humain..."*
- R√©v√®le la v√©rit√© **progressivement** :
  1. D'abord des **indices indirects** (empreintes, bruits).
  2. Puis des **aper√ßus** (queue qui dispara√Æt dans les buissons).
  3. Enfin, une **rencontre claire** (ex : un raptor bloquant le chemin de l'h√©liport).
""",
    )
    SCENARIOS[sc.id] = sc
    logger.info(f"Demo scenario created: {sc.id}")


@app.post("/games/{game_id}/choose", response_model=Game)
async def choose_option(game_id: str, req: ChooseOptionRequest):
    game = GAMES.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")

    player = next((p for p in game.players if p.player_id == req.player_id), None)
    if not player:
        raise HTTPException(status_code=400, detail="Player not part of this game")

    if not game.history:
        raise HTTPException(status_code=400, detail="No action history found")

    last_action = game.history[-1]
    if "options" not in last_action:
        raise HTTPException(status_code=400, detail="No options in last action")

    # Convertir option_id en entier
    option_id = int(req.option_id)

    # Rechercher l'option choisie
    chosen_option = None
    for opt in last_action["options"]:
        if int(opt["id"]) == option_id:
            chosen_option = opt
            break

    if not chosen_option:
        available_ids = [int(opt["id"]) for opt in last_action["options"]]
        raise HTTPException(
            status_code=400,
            detail=f"Option {option_id} not found. Available IDs: {available_ids}"
        )

    # Appliquer les multiplicateurs
    if "health_point_change" in chosen_option:
        hp_change = chosen_option["health_point_change"] * 100
        player.hp = max(0, min(100, player.hp + hp_change))
        logger.debug(f"HP updated: {player.hp} (change: {hp_change})")

    if "mana_point_change" in chosen_option:
        mp_change = chosen_option["mana_point_change"] * 100
        player.mp = max(0, min(100, player.mp + mp_change))
        logger.debug(f"MP updated: {player.mp} (change: {mp_change})")

    # Mettre √† jour l'historique
    last_action["chosen_option"] = option_id
    game.last_updated = datetime.utcnow()

    return game
